import numpy as np
import argparse
import pickle
import os

def getSDPs(path, trees):
    """
    Finds the sdp files generated by the INRIA tool.

    INPUT
    path: a str, path to the directory containing the sdp files. This directory is expected to have the following structure:
        specified_direcory
            -- tree_species
                -- tree_id.sdp
    trees: a dictionnary with the following structure:
        tree species:
          -- tree_id
                -- path
    """
    folders = [file for file in os.listdir(path) if os.path.isdir(os.path.join(path,file))]
    for folder in folders:
        if folder not in trees.keys():
            trees[folder] = {}
        files = os.listdir(os.path.join(path,folder))
        for file in files:
            id = file.split('_')[0]
            if id not in trees[folder].keys():
                trees[folder][id] = {}
            trees[folder][id]['path'] = os.path.join(path,folder,file)
    return trees

def getImages(path, trees):
    """
    Finds the images of the INRAE

    INPUT
    path: a str, path to the directory containing the images. This directory is expected to have the following structure:
        specified_direcory
            -- tree_species
                -- tree_id.sdp
    trees: a dictionnary with the following structure:
        tree species:
          -- tree_id
                -- path
    OUTPUT
    trees: a dictionnary with the following structure:
        tree_species:
          -- tree_id:
                -- path: the path to the sdp file associated with this tree_id
                --images:
                    -- number: the path to the image that corresponds to this slice number
    """
    folders = [file for file in os.listdir(path) if os.path.isdir(os.path.join(path,file))]
    for folder in folders:
        if folder not in trees.keys():
            continue
        ids = os.listdir(os.path.join(path,folder))
        for id in ids:
            if id not in trees[folder].keys():
                continue
            images = [image for image in os.listdir(os.path.join(path,folder,id)) if image.split('.')[-1]=='png']
            trees[folder][id]['images'] = {}
            for image in images:
                number = int(image.split('.')[0])
                trees[folder][id]['images'][number] = os.path.join(path,folder,id,image)
    return trees                

def getCuts(path, trees):
    """
    Reads a user made file that contains information regarding which slices can be reliably used.

    INPUT
    path: a str, the path to the file containing the info regarding the sdp files.
    trees: a dictionnary with the following structure:
        tree_species:
          -- tree_id:
                -- path: the path to the sdp file associated with this tree_id
                --images:
                    -- number: the path to the image that corresponds to this slice number
    OUTPUT
    selected_trees: a dictionnary with the following structure:
        tree_species:
          -- tree_id:
                -- path: the path to the sdp file associated with this tree_id
                -- cut: a list, it describes which slices can be reliably used
                --images:
                    -- number: the path to the image that corresponds to this slice number
    """
    file = open(path,'r')
    cuts = file.readlines()
    file.close()
    cuts = [cut.strip() for cut in cuts]
    ids_plus = [cut.split(':') for cut in cuts]
    selected_trees = {}
    for id, cut in ids_plus:
        target_tree = None
        for tree in trees.keys():
            for tree_id in trees[tree].keys():
                if tree_id == id:
                    target_tree = tree
        if not target_tree:
            continue
        trees[target_tree][id]['cut'] = [s.split('-') for s in cut.split(';')]
        if target_tree not in selected_trees.keys():
            selected_trees[target_tree] = {}
        selected_trees[target_tree][id] = trees[target_tree][id]
    return selected_trees

def build(trees):
    """
    Reads the SDP files and builds a dataset to teach a neural network to find trees center in Xray images.

    INPUT
    trees: a dictionnary with the following structure:
        tree_species:
          -- tree_id:
                -- path: the path to the sdp file associated with this tree_id
                -- cut: a list, it describes which slices can be reliably used
                --images:
                    -- number: the path to the image that corresponds to this slice number
    OUTPUT
    dataset: a dictionnary with the following structure:
        sample_number:
            -- data:
                -- index:
                    -- img_path: a str, absolute path to the image.
                    -- center: [x,y]. the x and y coordinates of the center.
            -- length: length of the sequence
            -- start: starting index of the sequence
            -- end: ending index of the sequence
    """
    dataset = {}
    num = 0
    for tree in trees.keys():
        for id in trees[tree].keys():
            for cut in trees[tree][id]['cut']:
                sample = {}
                sample['data'] = {}
                centers = read_sdp(trees[tree][id]['path'])
                check = np.max(list(trees[tree][id]['images'].keys())) == len(trees[tree][id]['images'].keys())
                if not check:
                    continue 
                for index in range(int(cut[0]),int(cut[1]),1):
                    sample['data'][index] = {}
                    sample['data'][index]['img_path'] = trees[tree][id]['images'][index]
                    sample['data'][index]['center'] = centers[index]
                sample['length'] = int(cut[1]) - int(cut[0])
                sample['start'] = int(cut[0])
                sample['end'] = int(cut[1])
                dataset[num] = sample
                num += 1
    return dataset

def read_sdp(path):
    """
    Reads an SDP file.

    INPUT
    path: a str, the path to the sdp file.
    OUTPUT
    centers: a list of float containing the position of the centers
    """
    file = open(path,'r')
    centers = file.readlines()[2:]
    file.close()
    centers = [[float(i) for i in center.strip().split(' ')] for center in centers]
    return centers

def save(dataset,path):
    """
    Saves a dictionnary as a pickle file in binary format

    INPUT
    dataset: a dictionnary
    path: a str, the path where to save the dictionnary
    OUTPUT
    True
    """
    with open(path, 'wb') as handle:
        pickle.dump(dataset, handle, protocol=pickle.HIGHEST_PROTOCOL)
    return True

def parse():
    parser = argparse.ArgumentParser()
    parser.add_argument('--image_path',type=str)
    parser.add_argument('--sdp_path',type=str)
    parser.add_argument('--cut_file',type=str)
    parser.add_argument('--save_path',type=str,default="dataset.pkl")
    return parser.parse_args()

args = parse()

trees = {}
trees = getSDPs(args.sdp_path, trees)
trees = getImages(args.image_path,trees)
trees = getCuts(args.cut_file, trees)
print(trees)
dataset = build(trees)
save(dataset, args.save_path)
