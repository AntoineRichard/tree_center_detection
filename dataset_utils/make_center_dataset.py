import numpy as np
import argparse
import pickle
import h5py
import os

def getPKLs(path, trees):
    """! Finds the pkl files generated by our neural-network.

    @type path: str
    @param path: path to the directory containing the sdp files. This directory is expected to have the following structure:
        -- specified_directory
            -- tree_species
                -- tree_id.pkl
    @type trees: dict
    @param trees: a dictionnary

    @rtype: dict
    @return: a dictionnary with the following structure
        -- tree_id
            -- path
    """
    folders = [file for file in os.listdir(path) if os.path.isdir(os.path.join(path,file))]
    for folder in folders:
        files = os.listdir(os.path.join(path,folder))
        for file in files:
            id = file.split('.')[0]
            if id not in trees.keys():
                trees[id] = {}
            trees[id]['path'] = os.path.join(path,folder,file)
            trees[id]['specie'] = folder
    return trees

def getSDPs(path, trees):
    """! Finds the sdp files generated by the INRIA tool.

    @type path: str
    @param path: path to the directory containing the sdp files. This directory is expected to have the following structure:
        -- specified_directory
            -- tree_species
                -- tree_id.sdp
    @type trees: dict
    @param trees: a dictionnary

    @rtype: dict
    @return: a dictionnary with the following structure
        -- tree_id
            -- path
    """
    folders = [file for file in os.listdir(path) if os.path.isdir(os.path.join(path,file))]
    for folder in folders:
        files = os.listdir(os.path.join(path,folder))
        for file in files:
            id = file.split('_')[0]  
            if id not in trees.keys():
                trees[id] = {}
            trees[id]['path'] = os.path.join(path,folder,file)
            trees[id]['specie'] = folder
    return trees

def getImages(path, trees):
    """! Finds the images of the INRAE
    @type path: str
    @param path: path to the directory containing the images. This directory is expected to have the following structure:
        -- specified_directory
            -- tree_species
                -- tree_id
                    -- img_i ....
    @type
    @param trees: a dictionnary with the following structure:
        -- tree_id
            -- path
    OUTPUT
    trees: a dictionnary with the following structure:
        -- tree_species:
            -- path: the path to the sdp file associated with this tree_id
            --images:
                -- number: the path to the image that corresponds to this slice number
    """
    folders = [file for file in os.listdir(path) if os.path.isdir(os.path.join(path,file))]
    for folder in folders:
        ids = os.listdir(os.path.join(path,folder))
        for id in ids:
            if id not in trees.keys():
                continue
            images = [image for image in os.listdir(os.path.join(path,folder,id)) if image.split('.')[-1]=='png']
            trees[id]['images'] = {}
            for image in images:
                number = int(image.split('.')[0])
                trees[id]['images'][number] = os.path.join(path,folder,id,image)
    return trees                

def getHDF5(path):
    """! Reads the keys from the HDF5 file

    @type path: str
    @param path: a str, path to the h5 file.
    @rtype: list
    @return: a list of id
    """
    h5 = h5py.File(path,'r')
    ids = [id for id in h5.keys()]
    return ids, h5

def getCutsImage(path, trees):
    """! Reads a user made file that contains information regarding which slices can be reliably used.

    @type path: str
    @param path: a str, the path to the file containing the info regarding the sdp files.
    @type trees: dict
    @param trees: a dictionnary with the following structure:
        -- tree_id:
            -- path: the path to the sdp file associated with this tree_id
            --images:
                -- number: the path to the image that corresponds to this slice number
    
    @rtype: dict
    @return: a dictionnary with the following structure:
        -- tree_id:
            -- path: the path to the sdp file associated with this tree_id
            -- cut: a list, it describes which slices can be reliably used
            --images:
                -- number: the path to the image that corresponds to this slice number
    """
    # Loads the file
    file = open(path,'r')
    cuts = file.readlines()
    file.close()
    # Clean strings
    cuts = [cut.strip() for cut in cuts]
    cuts = [cut for cut in cuts if cut]
    cuts = [cut for cut in cuts if cut[0]!="#"]
    # Read the val/test flags.
    val_trees = [cut for cut in cuts if "val" in cut]
    test_trees = [cut for cut in cuts if "test" in cut]
    train_trees = [cut for cut in cuts if not ((cut in val_trees) or (cut in test_trees))]
    # Remove the flags
    val_trees = [cut.split('(')[0] for cut in val_trees]
    test_trees = [cut.split('(')[0] for cut in test_trees]
    # Build dictionnaries
    train_trees = instantiateIDDict(train_trees)
    test_trees = instantiateIDDict(test_trees)
    val_trees = instantiateIDDict(val_trees)

    return train_trees, test_trees, val_trees

def getCutsHDF5(path, trees, h5ids):
    """! Reads a user made file that contains information regarding which slices can be reliably used.

    @type path: str
    @param path: a str, the path to the file containing the info regarding the sdp files.
    @type trees: dict
    @param trees: a dictionnary with the following structure:
        -- tree_id:
    @type h5ids: list
    @param h5ids: a list of id
    
    @rtype: dict
    @return: a dictionnary with the following structure:
        -- tree_id:
            -- cut: a list, it describes which slices can be reliably used
    """
    # Loads the file
    file = open(path,'r')
    cuts = file.readlines()
    file.close()
    # Clean strings
    cuts = [cut.strip() for cut in cuts]
    cuts = [cut for cut in cuts if cut]
    cuts = [cut for cut in cuts if cut[0]!="#"]
    # Read the val/test flags.
    val_trees = [cut for cut in cuts if "val" in cut]
    test_trees = [cut for cut in cuts if "test" in cut]
    train_trees = [cut for cut in cuts if not ((cut in val_trees) or (cut in test_trees))]
    # Remove the flags
    val_trees = [cut.split('(')[0] for cut in val_trees]
    test_trees = [cut.split('(')[0] for cut in test_trees]
    # Build dictionnaries
    train_trees = instantiateIDDict(train_trees, h5ids)
    test_trees = instantiateIDDict(test_trees, h5ids)
    val_trees = instantiateIDDict(val_trees, h5ids)

    return train_trees, test_trees, val_trees

def instantiateIDDict(cuts, h5ids):
    """! Reads a list of cut instructions and creates a dictionnary from it.

    @type cuts: list
    @param cuts: a list containing cut instructions. With this syntax:
        ["tree_id:cut0_start_index-cut0_end_index;cut1_start_index-cut1_end_index;...","tree_id:..."]

    @rtype: dict
    @return: a dictionnary with the following structure:
        -- tree_id:
            -- cut: a list, it describes which slices can be reliably used
    """
    # Split by id
    ids_plus = [cut.split(':') for cut in cuts]
    # Get cuts per tree id
    selected_trees = {}
    for id, cut in ids_plus:
        tree_exists = False
        if (id in h5ids) and (id in trees.keys()):
            tree_exists = True
        if not tree_exists:
            continue
        trees[id]['cut'] = [s.split('-') for s in cut.split(';')]
        trees[id]['cut'] = [cut for cut in trees[id]['cut'] if cut[0]]
        selected_trees[id] = trees[id]
    return selected_trees

def buildImage(trees, use_pkl=False):
    """! Aggregates all the data into a single dictionnary file that can be used to teach a neural network to find trees center in Xray images.

    @type trees: dict
    @param trees: a dictionnary with the following structure:
        -- tree_id:
              -- path: the path to the sdp file associated with this tree_id
              -- cut: a list, it describes which slices can be reliably used
              --images:
                  -- number: the path to the image that corresponds to this slice number
    
    @rtype: dict
    @return: a dictionnary with the following structure:
        -- sample_number:
            -- data:
                -- index:
                    -- img_path: a str, absolute path to the image.
                    -- center: [x,y]. the x and y coordinates of the center.
            -- length: length of the sequence
            -- start: starting index of the sequence
            -- end: ending index of the sequence
    """
    dataset = {}
    num = 0
    for id in trees.keys():
        for cut in trees[id]['cut']:
            sample = {}
            sample['data'] = {}
            if use_pkl:
                centers = read_pkl(trees[id]['path'])
            else:
                centers = read_sdp(trees[id]['path'])
            check = np.max(list(trees[id]['images'].keys())) == len(trees[id]['images'].keys())
            if not check:
                continue 
            for index in range(int(cut[0]),int(cut[1]),1):
                sample['data'][index] = {}
                sample['data'][index]['img_path'] = trees[id]['images'][index]
                sample['data'][index]['center'] = centers[index]
            sample['length'] = int(cut[1]) - int(cut[0])
            sample['start'] = int(cut[0])
            sample['end'] = int(cut[1])
            dataset[num] = sample
            num += 1
    return dataset

def buildHDF5(trees, h5, use_pkl=False):
    """! Aggregates all the data into a single dictionnary file that can be used to teach a neural network to find trees center in Xray images.

    @type trees: dict
    @param trees: a dictionnary with the following structure:
        -- tree_id:
              -- path: the path to the sdp file associated with this tree_id
              -- cut: a list, it describes which slices can be reliably used
    
    @rtype: dict
    @return: a dictionnary with the following structure:
        -- sample_number:
            -- data:
                -- index:
                    -- img_path: a str, absolute path to the image.
                    -- center: [x,y]. the x and y coordinates of the center.
            -- length: length of the sequence
            -- start: starting index of the sequence
            -- end: ending index of the sequence
    """
    dataset = {}
    num = 0
    for id in trees.keys():
        # Get the name of each slice
        image_slice_number = [int(i) for i in list(h5[id].keys())]
        image_slice_number.sort()
        image_slice_number = np.array(image_slice_number)
        indexes = np.arange(len(image_slice_number))
        # Get the centers
        if use_pkl:
            centers = read_pkl(trees[id]['path'])
        else:
            centers = read_sdp(trees[id]['path'])

        for cut in trees[id]['cut']:
            # instantiate dictionnary
            sample = {}
            sample['centers'] = {}
            sample['tree_id'] = id
            # Mask based on the name of the slices
            mask = (image_slice_number <= int(cut[1])) * (image_slice_number >= int(cut[0]))
            # Use both slice name and image index to create dataset
            for index,name in zip(indexes[mask], image_slice_number[mask]):
                sample['centers'][name] = centers[index]
            # Add meta-data regarding the sequence
            sample['length'] = int(cut[1]) - int(cut[0])
            sample['start'] = int(cut[0])
            sample['end'] = int(cut[1])
            dataset[num] = sample
            num += 1
    return dataset

def read_sdp(path):
    """! Reads an SDP file.

    @type path: str
    @param path: the path to the sdp file.

    @rtype: list
    @return: a list of float containing the position of the centers
    """
    file = open(path,'r')
    centers = file.readlines()[2:]
    file.close()
    centers = [[float(i) for i in center.strip().split(' ')] for center in centers]
    return centers

def read_pkl(path):
    """! Reads the PKL file generated by our neural-network.

    @type path: str
    @param path: the path to the pkl file.

    @rtype: list
    @return: a list of float containing the position of the centers
    """
    file = open(path,'rb')
    data = pickle.load(file)
    file.close()
    center = np.array(data['std'])
    return center

def save(dct, path):
    """! Saves a dictionnary as a pickle file in binary format

    @type dataset: dct
    @param dct: a dictionnary.
    @type path: str
    @param path: the path where to save the dictionnary.
    
    @rtype: bool
    @return: True if the file was saved sucessfully
    """
    with open(path, 'wb') as handle:
        pickle.dump(dct, handle, protocol=pickle.HIGHEST_PROTOCOL)
    return True

if __name__ == "__main__":

    def parse():
        parser = argparse.ArgumentParser()
        parser.add_argument('--image_path',type=str)
        parser.add_argument('--sdp_path',type=str)
        parser.add_argument('--cut_file',type=str)
        parser.add_argument('--use_hdf5',type=bool)
        parser.add_argument('--use_pkl',type=bool)
        parser.add_argument('--save_path',type=str,default="dataset.pkl")
        return parser.parse_args()

    args = parse()

    trees = {}
    if args.use_pkl:
        trees = getPKLs(args.sdp_path, trees)
    else:
        trees = getSDPs(args.sdp_path, trees)
    if args.use_hdf5:
        ids, h5 = getHDF5(args.image_path)
        train_cut, test_cut, val_cut = getCutsHDF5(args.cut_file, trees, ids)
        train_dataset = buildHDF5(train_cut, h5, use_pkl = args.use_pkl)
        test_dataset = buildHDF5(test_cut, h5, use_pkl = args.use_pkl)
        val_dataset = buildHDF5(val_cut, h5, use_pkl = args.use_pkl)
    else:
        trees = getImages(args.image_path,trees)
        train_cut, test_cut, val_cut = getCutsImage(args.cut_file, trees)
        train_dataset = buildImage(train_cut, use_pkl = args.use_pkl)
        test_dataset = buildImage(test_cut, use_pkl = args.use_pkl)
        val_dataset = buildImage(val_cut, use_pkl = args.use_pkl)
    save(train_dataset, args.save_path+"_train.pkl")
    save(test_dataset, args.save_path+"_test.pkl")
    save(val_dataset, args.save_path+"_val.pkl")
