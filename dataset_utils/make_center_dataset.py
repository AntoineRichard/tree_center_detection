import numpy as np
import argparse
import pickle
import h5py
import os

def getSDPs(path, trees):
    """! Finds the sdp files generated by the INRIA tool.

    @type path: str
    @param path: path to the directory containing the sdp files. This directory is expected to have the following structure:
        -- specified_directory
            -- tree_species
                -- tree_id.sdp
    @type trees: dict
    @param trees: a dictionnary

    @rtype: dict
    @return: a dictionnary with the following structure
        -- tree_id
            -- path
    """
    folders = [file for file in os.listdir(path) if os.path.isdir(os.path.join(path,file))]
    for folder in folders:
        files = os.listdir(os.path.join(path,folder))
        for file in files:
            id = file.split('_')[0]
            if id not in trees.keys():
                trees[id] = {}
            trees[id]['path'] = os.path.join(path,folder,file)
    return trees

def getImages(path, trees):
    """! Finds the images of the INRAE
    @type path: str
    @param path: path to the directory containing the images. This directory is expected to have the following structure:
        -- specified_directory
            -- tree_species
                -- tree_id
                    -- img_i ....
    @type
    @param trees: a dictionnary with the following structure:
        -- tree_id
            -- path
    OUTPUT
    trees: a dictionnary with the following structure:
        -- tree_species:
            -- path: the path to the sdp file associated with this tree_id
            --images:
                -- number: the path to the image that corresponds to this slice number
    """
    folders = [file for file in os.listdir(path) if os.path.isdir(os.path.join(path,file))]
    for folder in folders:
        ids = os.listdir(os.path.join(path,folder))
        for id in ids:
            if id not in trees.keys():
                continue
            images = [image for image in os.listdir(os.path.join(path,folder,id)) if image.split('.')[-1]=='png']
            trees[id]['images'] = {}
            for image in images:
                number = int(image.split('.')[0])
                trees[id]['images'][number] = os.path.join(path,folder,id,image)
    return trees                

def getHDF5(path):
    """! Reads the keys from the HDF5 file

    @type path: str
    @param path: a str, path to the directory containing the images. This directory is expected to have the following structure:
        specified_directory
            -- tree_species
                -- tree_id
                    -- img_i ....
    @rtype: list
    @return: a list of id
    """
    h5 = h5py.File(path,'r')
    ids = [id for id in h5.keys()]
    return ids

def getCutsImage(path, trees):
    """! Reads a user made file that contains information regarding which slices can be reliably used.

    @type path: str
    @param path: a str, the path to the file containing the info regarding the sdp files.
    @type trees: dict
    @param trees: a dictionnary with the following structure:
        -- tree_id:
            -- path: the path to the sdp file associated with this tree_id
            --images:
                -- number: the path to the image that corresponds to this slice number
    
    @rtype: dict
    @return: a dictionnary with the following structure:
        -- tree_id:
            -- path: the path to the sdp file associated with this tree_id
            -- cut: a list, it describes which slices can be reliably used
            --images:
                -- number: the path to the image that corresponds to this slice number
    """
    file = open(path,'r')
    cuts = file.readlines()
    file.close()
    cuts = [cut.strip() for cut in cuts]
    ids_plus = [cut.split(':') for cut in cuts]
    selected_trees = {}
    for id, cut in ids_plus:
        tree_exists = None
        for tree_id in trees.keys():
            if tree_id == id:
                tree_exists = True
        if not tree_exists:
            continue
        trees[id]['cut'] = [s.split('-') for s in cut.split(';')]
        selected_trees[id] = trees[id]
    return selected_trees

def getCutsHDF5(path, trees, h5ids):
    """! Reads a user made file that contains information regarding which slices can be reliably used.

    @type path: str
    @param path: a str, the path to the file containing the info regarding the sdp files.
    @type trees: dict
    @param trees: a dictionnary with the following structure:
        -- tree_id:
            -- path: the path to the sdp file associated with this tree_id
            --images:
                -- number: the path to the image that corresponds to this slice number
    @type h5ids: list
    @param h5ids: a list of id
    
    @rtype: dict
    @return: a dictionnary with the following structure:
        -- tree_id:
            -- path: the path to the sdp file associated with this tree_id
            -- cut: a list, it describes which slices can be reliably used
            --images:
                -- number: the path to the image that corresponds to this slice number
    """
    file = open(path,'r')
    cuts = file.readlines()
    file.close()
    cuts = [cut.strip() for cut in cuts]
    ids_plus = [cut.split(':') for cut in cuts]
    selected_trees = {}
    for id, cut in ids_plus:
        tree_exists = False
        if (id in h5ids) and (id in trees.keys()):
            tree_exists = True
        if not tree_exists:
            continue
        trees[id]['cut'] = [s.split('-') for s in cut.split(';')]
        selected_trees[id] = trees[id]
    return selected_trees

def buildImage(trees):
    """! Aggregates all the data into a single dictionnary file that can be used to teach a neural network to find trees center in Xray images.

    @type trees: dict
    @param trees: a dictionnary with the following structure:
        -- tree_id:
              -- path: the path to the sdp file associated with this tree_id
              -- cut: a list, it describes which slices can be reliably used
              --images:
                  -- number: the path to the image that corresponds to this slice number
    
    @rtype: dict
    @return: a dictionnary with the following structure:
        -- sample_number:
            -- data:
                -- index:
                    -- img_path: a str, absolute path to the image.
                    -- center: [x,y]. the x and y coordinates of the center.
            -- length: length of the sequence
            -- start: starting index of the sequence
            -- end: ending index of the sequence
    """
    dataset = {}
    num = 0
    for id in trees.keys():
        for cut in trees[id]['cut']:
            sample = {}
            sample['data'] = {}
            centers = read_sdp(trees[id]['path'])
            check = np.max(list(trees[id]['images'].keys())) == len(trees[id]['images'].keys())
            if not check:
                continue 
            for index in range(int(cut[0]),int(cut[1]),1):
                sample['data'][index] = {}
                sample['data'][index]['img_path'] = trees[id]['images'][index]
                sample['data'][index]['center'] = centers[index]
            sample['length'] = int(cut[1]) - int(cut[0])
            sample['start'] = int(cut[0])
            sample['end'] = int(cut[1])
            dataset[num] = sample
            num += 1
    return dataset

def buildHDF5(trees):
    """! Aggregates all the data into a single dictionnary file that can be used to teach a neural network to find trees center in Xray images.

    @type trees: dict
    @param trees: a dictionnary with the following structure:
        -- tree_id:
              -- path: the path to the sdp file associated with this tree_id
              -- cut: a list, it describes which slices can be reliably used
    
    @rtype: dict
    @return: a dictionnary with the following structure:
        -- sample_number:
            -- data:
                -- index:
                    -- img_path: a str, absolute path to the image.
                    -- center: [x,y]. the x and y coordinates of the center.
            -- length: length of the sequence
            -- start: starting index of the sequence
            -- end: ending index of the sequence
    """
    dataset = {}
    num = 0
    for id in trees.keys():
        for cut in trees[id]['cut']:
            sample = {}
            sample['centers'] = {}
            centers = read_sdp(trees[id]['path'])
            #check = np.max(list(trees[id]['images'].keys())) == len(trees[id]['images'].keys())
            sample['tree_id'] = id
            #if not check:
            #    continue 
            for index in range(int(cut[0]),int(cut[1]),1):
                sample['centers'][index] = centers[index]
            sample['length'] = int(cut[1]) - int(cut[0])
            sample['start'] = int(cut[0])
            sample['end'] = int(cut[1])
            dataset[num] = sample
            num += 1
    return dataset

def read_sdp(path):
    """! Reads an SDP file.

    @type path: str
    @param path: the path to the sdp file.

    @rtype: list
    @return: a list of float containing the position of the centers
    """
    file = open(path,'r')
    centers = file.readlines()[2:]
    file.close()
    centers = [[float(i) for i in center.strip().split(' ')] for center in centers]
    return centers

def save(dct, path):
    """! Saves a dictionnary as a pickle file in binary format

    @type dataset: dct
    @param dct: a dictionnary.
    @type path: str
    @param path: the path where to save the dictionnary.
    
    @rtype: bool
    @return: True if the file was saved sucessfully
    """
    with open(path, 'wb') as handle:
        pickle.dump(dct, handle, protocol=pickle.HIGHEST_PROTOCOL)
    return True

if __name__ == "__main__":

    def parse():
        parser = argparse.ArgumentParser()
        parser.add_argument('--image_path',type=str)
        parser.add_argument('--sdp_path',type=str)
        parser.add_argument('--cut_file',type=str)
        parser.add_argument('--use_hdf5',type=bool)
        parser.add_argument('--save_path',type=str,default="dataset.pkl")
        return parser.parse_args()

    args = parse()

    trees = {}
    trees = getSDPs(args.sdp_path, trees)
    if args.use_hdf5:
        ids = getHDF5(args.image_path)
        trees = getCutsHDF5(args.cut_file, trees, ids)
        dataset = buildHDF5(trees)
    else:
        trees = getImages(args.image_path,trees)
        trees = getCutsImage(args.cut_file, trees)
        dataset = buildImage(trees)
    save(dataset, args.save_path)
