import tensorflow.compat.v1 as tf1
from subprocess import Popen, PIPE
from skimage import exposure
import tensorflow as tf
import skimage as ski
import numpy as np
import random
import scipy
import cv2

class MRINoiseGenerator:
    def __init__(self, im_size=256):
        self.im_size = im_size

    def genMRINoise(self, num_map=100):
        """! Creates a noise map that looks like the one generated by
         MRI machines and applies it to images.

        @type x: tf.tensor
        @param x: a tensor of shape [Height, Width, Sequence_size]
    
        @rtype: tf.tensor
        @return: a tensor of shape [Height, Width, Sequence_size]
        """
        map_size = 1024
        self.maps = []
        for i in range(num_map):
            LR_noise = np.random.normal(0,0.01**2,(256,256//16))
            LR_noise = cv2.resize(LR_noise,(map_size,map_size))
            MR_noise = np.random.normal(0,0.01**2,(256,256//4))
            MR_noise = cv2.resize(MR_noise,(map_size,map_size))
            HR_noise = np.random.normal(0,0.01**2,(256,256))
            HR_noise = cv2.resize(HR_noise,(map_size,map_size))
            full_noise = LR_noise + MR_noise + HR_noise
            normed_noise = (normalize(full_noise)*32000).astype(np.int16)
            polar_noise = cv2.warpPolar(normed_noise, (map_size,map_size), (map_size//2,map_size//2), map_size//2, cv2.WARP_POLAR_LINEAR + cv2.WARP_INVERSE_MAP)
            mask = np.zeros((map_size,map_size),np.int16)
            mask = cv2.circle(mask, (map_size//2,map_size//2), map_size//2 ,0xFFFF, -1)
            polar_noise = polar_noise & mask
            polar_noise_rs = cv2.resize(polar_noise,(self.im_size,self.im_size))
            self.maps.append(normalize(polar_noise_rs.astype(np.float32)))

    def applyRandomNoise(self, x):
        noise = random.choice(self.maps)
        noise_mean = np.mean(noise)
        mask = np.zeros_like(x)
        mask = cv2.circle(mask, (self.im_size//2,self.im_size//2), int(0.95*self.im_size//2), 1, int(0.05*self.im_size//2))
        x = x + noise * np.random.rand()*0.5
        x[mask] = noise_mean
        x[x<=noise_mean] = noise_mean
        return x

class OuterRingRemover:
    def __init__(self, min_radius=45, max_radius=120, im_size=256):
        self.min_radius = min_radius
        self.max_radius = max_radius
        self.im_size = im_size

    def makeMask(self):
        self.masks = []
        for i in range(self.min_radius, self.max_radius, 2):
            m = np.zeros((self.im_size, self.im_size), dtype=np.int16)
            self.masks.append(cv2.circle(m,(self.im_size//2,self.im_size//2),i,0xFFFF,thickness=-1))
    
    def applyRandomMask(self, x, y, eps=30):
        # Add noise to prevent the network from finding the center using the mask
        y0 = y[0] - self.im_size//2 + int(np.random.rand()*eps - eps/2)
        y1 = y[1] - self.im_size//2 + int(np.random.rand()*eps - eps/2)
        y00 = (y0>0)*y0 + 1*(y0<0)
        y01 = (y0<0)*y0 - 1*(y0>0)
        y10 = (y1>0)*y1 + 1*(y1<0)
        y11 = (y1<0)*y1 - 1*(y1>0)
        mask = np.zeros((self.im_size, self.im_size), dtype=np.int16)
        mask[y00:y01,y10:y11] = random.choice(self.masks)[-y01:-y00,-y11:-y10]
        return x & mask

def histogramCut(img, shift = 0., cap = 1.):
    """! Restricts the histogram to a range between 'shift' and 'cap'.

    @type img: np.array
    @param img: an ND array [?, .., ?]
    @type shift: float
    @param shift: a float between 0 and 1. With shift < cap.
    @type cap: float
    @param cap: a float between 0 and 1. With cap > shift.
    
    @rtype: np.array
    @return: an ND array [?, .., ?]
    """
    img = img
    img[img>cap] = cap

    img -= shift
    img[img<0] = 0.

    img /= (cap-shift)

    return img

def normalizeTF(img):
    """! Normalizes an image between 0 and 1

    @type img: tf.tensor
    @param img: an ND tensor [?, .., ?]

    @rtype: tf.tensor
    @return: an ND tensor [?, .., ?]
    """
    img = img - tf.reduce_min(img)
    img = img / tf.reduce_max(img)
    return img - 0.5

def normalize(img):
    """! Normalizes an image

    @type img: np.array
    @param img: an ND array [?, .., ?]

    @rtype: np.array
    @return: an ND array [?, .., ?]
    """
    img = img - np.amin(img)
    img = img / np.amax(img)
    return img

def equalize(img):
    """! Peforms adaptative histogram normalization on a flatten sequence of images

    @type img: np.array
    @param img: a 2D array [?, ?]
    
    @type ada: np.array
    @param ada: a 2D array [?, ?]
    """
    ada = normalize(img)
    ada = ski.exposure.equalize_adapthist(ada, clip_limit=0.02)
    ada = normalize(ada)
    ada = ski.exposure.adjust_log(ada, gain=1, inv= False)
    ada = histogramCut(ada)
    ada = normalize(ada) - 0.5
    return ada

def randomLowerImageMasking(x,y):
    """! Randomly removes the lower part of an image or a sequence of images

    @type x: tf.tensor
    @param x: a tensor of shape [Height, Width, Sequence_size]
    @type y: tf.tensor
    @param y: a tensor of shape [Sequence_size, 2]

    @rtype: tuple
    @return: a tuple of tensors of shape([Height, Width, Sequence_size], [Sequence_size, 2])
    """
    mask_height = int(np.random.rand()*2)
    min_pixels = 10
    max_pixels = 30
    x = np.array(x)
    if mask_height == 1:
        delta = int(min_pixels + np.random.rand()*(max_pixels - min_pixels))
        x[:,:int((y[0,0] + 0.5)*256 - delta)] = -0.5
    return x, y

def rotate(x, y):
    """! Rotates a whole sequence by a random amount

    @type x: tf.tensor
    @param x: a tensor of shape [Height, Width, Sequence_size]
    @type y: tf.tensor
    @param y: a tensor of shape [Sequence_size, 2]
    
    @rtype: tuple
    @return: a tuple of tensors of shape([Height, Width, Sequence_size], [Sequence_size, 2])
    """
    y = np.array(y)
    theta = np.random.rand()*3*np.pi/4
    c, s = np.cos(theta), np.sin(theta)
    R = np.array(((c, -s), (s, c)))
    y = np.matmul(R,y.T).T
    x = scipy.ndimage.rotate(x, -180*theta/np.pi, reshape=False, cval=-0.5)
    return (x,y)

def shift(x, y, max_shift=125):
    """! Shifts a whole sequence by a random amount

    @type x: tf.tensor
    @param x: a tensor of shape [Height, Width, Sequence_size]
    @type y: tf.tensor
    @param y: a tensor of shape [Sequence_size, 2]
    
    @rtype: tuple
    @return: a tuple of tensors of shape([Height, Width, Sequence_size], [Sequence_size, 2])
    """
    y = np.array(y)
    shifts = (np.random.rand(2) - 0.5)*max_shift/256
    x = scipy.ndimage.shift(x, [int(shifts[0]*256), int(shifts[1]*256), 0],cval=-0.5)
    y[:,0] = y[:,0] + shifts[1]
    y[:,1] = y[:,1] + shifts[0]
    return x, y

def augmentSequence(x,y):
    """
    Rotates a whole sequence by a random amount. To be used on a tf.dataset using map.

    INPUTS
    x: a tensor of shape [Sequence_size, Height, Width, 1]
    y: a tensor of shape [Sequence_size, 2]
    OUTPUTS
    x: a tensor of shape [Sequence_size, Height, Width, 1]
    y: a tensor of shape [Sequence_size, 2]
    """
    x = tf.squeeze(x) # [S,H,W,1] -> [S,H,W]
    x = tf.transpose(x,perm=[1,2,0]) # [S,H,W] -> [H,W,S]
    x,y = tf.py_function(rotate, [x,y], (tf.float32, tf.float32))
    x,y = tf.py_function(shift, [x,y], (tf.float32, tf.float32))
    x = tf.transpose(x,perm=[2,0,1])
    x = tf.expand_dims(x,-1)
    return x,y

def augmentImage(x,y):
    """
    Rotates a whole sequence by a random amount. To be used on a tf.dataset using map.

    INPUTS
    x: a tensor of shape [Height, Width, 1]
    y: a tensor of shape [2]
    OUTPUTS
    x: a tensor of shape [Height, Width, 1]
    y: a tensor of shape [2]
    """
    y = tf.expand_dims(y,0)
    x,y = tf.py_function(randomLowerImageMasking, [x,y], (tf.float32, tf.float32))
    x,y = tf.py_function(rotate, [x,y], (tf.float32, tf.float32))
    x,y = tf.py_function(randomLowerImageMasking, [x,y], (tf.float32, tf.float32))
    x,y = tf.py_function(rotate, [x,y], (tf.float32, tf.float32))
    x,y = tf.py_function(shift, [x,y], (tf.float32, tf.float32)) # replace by tf.roll ? More like a smart concat
    x = randomBrightnessContrast(x)
    x = gaussianNoise(x)
    x = normalizeTF(x)
    x,y = tf.py_function(randomRectMasking, [x,y], (tf.float32, tf.float32))
    #print(x)
    #x = tf.expand_dims(x,-1)
    y = tf.squeeze(y)
    #tf.print(x.shape,y.shape)
    return x,y

def applyCorrection(x):
    """
    Applies adaptative histogram normalization on a whole sequence. To be used on a tf.dataset using map.

    INPUT
    x: a tensor of shape [Sequence_size, Height, Width, 1]
    OUTPUT
    x: a tensor of shape [Sequence_size, Height, Width, 1]
    """
    s = x.shape
    x = tf.reshape(x, [s[0]*s[1],s[2]])
    x = tf.py_function(equalize, [x], tf.float32)
    x = tf.reshape(x, [s[0],s[1],s[2],1])
    return x

def applyCorrectionImage(x):
    """
    Applies adaptative histogram normalization on an image sequence. To be used on a tf.dataset using map.

    INPUT
    x: a tensor of shape [Sequence_size, Height, Width, 1]
    OUTPUT
    x: a tensor of shape [Sequence_size, Height, Width, 1]
    """
    x = tf.squeeze(x)
    x = tf.py_function(equalize, [x], tf.float32)
    x = tf.expand_dims(x,-1)
    return x

def randomBrightnessContrast(x, max_brightness_delta=0.2, max_contrast_factor=0.3):
    """! Randomly changes images brightness and contrast.
    @type x: tf.tensor
    @param x: a tensor of shape [Height, Width, Sequence_size]
    
    @rtype: tf.tensor
    @return: a tensor of shape [Height, Width, Sequence_size]
    """
    x = tf.image.random_brightness(x, max_brightness_delta)
    x = tf.image.random_contrast(x, 1 - max_contrast_factor, 1 + max_contrast_factor)
    return x

def gaussianNoise(x, mean=0.0, max_sigma=0.005**0.5):
    """! Adds a random amount of gausian noise to the images.
    @type x: tf.tensor
    @param x: a tensor of shape [Height, Width, Sequence_size]
    
    @rtype: tf.tensor
    @return: a tensor of shape [Height, Width, Sequence_size]
    """
    sigma = tf.random.uniform([1])*max_sigma
    gauss = tf.random.normal((256,256,1), mean, sigma)
    x = x + gauss
    return x

def MRINoise(x):
    """! Creates a noise map that looks like the one generated by
     MRI machines and applies it to images.

    @type x: tf.tensor
    @param x: a tensor of shape [Height, Width, Sequence_size]
    
    @rtype: tf.tensor
    @return: a tensor of shape [Height, Width, Sequence_size]
    """
    LR_noise = np.random.normal(256,10)
    LR_noise = cv2.resize(LR_noise,(256,256))
    MR_noise = np.random.normal(256,64)
    MR_noise = cv2.resize(MR_noise,(256,256))
    HR_noise = np.random.normal(256,256)
    full_noise = LR_noise + MR_noise + HR_noise
    polar_noise = cv2.warpPolar(full_noise, (256,256), (128,128), 128, cv2.WARP_POLAR_LINEAR + cv2.WARP_INVERSE_MAP)
    normed_polar_noise = normalize(polar_noise)
    noise_mean = np.mean(normed_polar_noise)
    mask = np.zeros_like(x)
    mask = cv2.circle(mask, (128,128), 122, 1, 5)
    x = x + normed_polar_noise * np.random.rand()*0.5
    x[mask] = noise_mean
    x[x<=noise_mean] = noise_mean
    return x

def randomKill(x, max_kills=4, kill_ratio=0.2):
    """! Selects one or more image of the sequence and randomly sets it to 0.
    @type x: tf.tensor
    @param x: a tensor of shape [Height, Width, Sequence_size]

    @rtype: tf.tensor
    @return: a tensor of shape [Height, Width, Sequence_size]
    """
    return x

def randomRectMasking(x, y, min_block_size=16, max_random_size=32, max_boxes=3):
    """! Creates blocks of random positions, values, and sizes in images.
    @type x: tf.tensor
    @param x: a tensor of shape [Height, Width, Sequence_size]
    @type max_block_size: int
    @param max_block_size: The maximum size of the blocks
    @type max_boxes: int
    @param max_boxes: The maximum number of boxes that can be added
    
    @rtype: tf.tensor
    @return: a tensor of shape [Height, Width, Sequence_size]
    """
    x = np.array(x)
    h, w, s = x.shape
    #tf.print(" == new == ")
    for i in range(s):
        boxes = int(np.random.rand()*max_boxes)
        for _ in range(boxes):
            xyhw = np.random.rand(4)
            xy = (xyhw[0:2]*256).astype(int)
            hw = min_block_size + (xyhw[2:]*max_random_size).astype(int)
            #tf.print(str(xy[0]))
            #tf.print(hw)
            x[xy[0]:xy[0]+hw[0],xy[1]:xy[1]+hw[1],i] =  - 0.5
    #tf.print(x.shape)
    return x,y

    

def encodeGif(frames, fps):
    """
    Encodes a GIF from a numpy array

    INPUTS
    frames: a numpy array of shape [Sequence_size, Height, Batch_size*Width, Channel]
    fps: an int, the number of frames per second to be used when encoding the GIF 
    OUTPUT
    out: the encoded GIF
    """
    h, w, c = frames[0].shape
    pxfmt = {1: 'gray', 3: 'rgb24'}[c]
    cmd = ' '.join(['ffmpeg -y -f rawvideo -vcodec rawvideo','-r '+str("%.02f"%fps)+' -s '+str(w)+'x'+str(h)+' -pix_fmt '+pxfmt+' -i - -filter_complex','[0:v]split[x][z];[z]palettegen[y];[x]fifo[x];[x][y]paletteuse','-r '+str("%.02f"%fps)+' -f gif -'])
    proc = Popen(cmd.split(' '), stdin=PIPE, stdout=PIPE, stderr=PIPE)
    for image in frames:
        proc.stdin.write(image.tostring())
    out, err = proc.communicate()
    if proc.returncode:
        raise IOError('\n'.join([' '.join(cmd), err.decode('utf8')]))
    del proc
    return out

def videoSummary(name, video, step=None, fps=10):
    """
    Allows to embed a video inside tensorboard

    INPUTS
    name: a string, the name of the video summary in tensorboard.
    video: a tensor of shape [Batch_size, Sequence_size, Height, Width, Channels]
    step: an int, the step at which for which this summary will be recorded
    fps: an int, the frame rate at which the GIF will be encoded
    """
    name = name if isinstance(name, str) else name.decode('utf-8')
    if np.issubdtype(video.dtype, np.floating):
        video = np.clip(255 * video, 0, 255).astype(np.uint8)
    B, T, H, W, C = video.shape
    try:
        frames = video.transpose((1, 2, 0, 3, 4)).reshape((T, H, B * W, C))
        summary = tf1.Summary()
        image = tf1.Summary.Image(height=B * H, width=T * W, colorspace=C)
        image.encoded_image_string = encodeGif(frames, fps)#.numpy()
        summary.value.add(tag=name + '/gif', image=image)
        tf.summary.experimental.write_raw_pb(summary.SerializeToString(), step)
    except (IOError, OSError) as e:
        print('GIF summaries require ffmpeg in $PATH.', e)
        frames = video.transpose((0, 2, 1, 3, 4)).reshape((1, B * H, T * W, C))
        tf.summary.image(name + '/grid', frames.astype(np.uint8), step)

def imageSummaryCross(name, img, coords, step=None):
    """
    Allows to embed a video inside tensorboard with a red cross at the coordinates given in 'coords'.

    INPUTS
    name: a string, the name of the video summary in tensorboard.
    video: a tensor of shape [Batch_size, Sequence_size, Height, Width, Channels]
    coord: a tensor of shape [Batch_size, Sequence_size, 2]
    step: an int, the step at which for which this summary will be recorded
    fps: an int, the frame rate at which the GIF will be encoded
    name = name if isinstance(name, str) else name.decode('utf-8')
    """
    if np.issubdtype(img.dtype, np.floating):
        img = np.clip(255 * img, 0, 255).astype(np.uint8)
    img2 = np.zeros((img.shape[0],img.shape[1],img.shape[2],3),dtype=np.uint8)
    coords = np.array(coords).astype(np.int32)
    for i in range(img.shape[0]):
        img2[i] = cv2.drawMarker(np.repeat(img[i],3,-1), (coords[i,0],coords[i,1]),markerType=cv2.MARKER_CROSS,color=(255,0,0))
    tf.summary.image(name, img2.astype(np.uint8), step)

def videoSummaryCross(name, video, coords, step=None, fps=10):
    """
    Allows to embed a video inside tensorboard with a red cross at the coordinates given in 'coords'.
    INPUTS
    name: a string, the name of the video summary in tensorboard.
    video: a tensor of shape [Batch_size, Sequence_size, Height, Width, Channels]
    coord: a tensor of shape [Batch_size, Sequence_size, 2]
    step: an int, the step at which for which this summary will be recorded
    fps: an int, the frame rate at which the GIF will be encoded
    name = name if isinstance(name, str) else name.decode('utf-8')
    """
    if np.issubdtype(video.dtype, np.floating):
        video = np.clip(255 * video, 0, 255).astype(np.uint8)
    video2 = np.zeros((video.shape[0],video.shape[1],video.shape[2],video.shape[3],3),dtype=np.uint8)
    B, T, H, W, C = video2.shape
    coords = np.array(coords).astype(np.int32)
    try:
        for i in range(video.shape[0]):
              for j in range(video.shape[1]):
                  video2[i,j] = cv2.drawMarker(np.repeat(video[i,j],3,-1), (coords[i,j,0],coords[i,j,1]),markerType=cv2.MARKER_CROSS,color=(255,0,0))
        frames = video2.transpose((1, 2, 0, 3, 4)).reshape((T, H, B * W, C))
        summary = tf1.Summary()
        image = tf1.Summary.Image(height=B * H, width=T * W, colorspace=C)
        image.encoded_image_string = encodeGif(frames, fps)#.numpy()
        summary.value.add(tag=name + '/gif', image=image)
        tf.summary.experimental.write_raw_pb(summary.SerializeToString(), step)
    except (IOError, OSError) as e:
        print('GIF summaries require ffmpeg in $PATH.', e)
        frames = video2.transpose((0, 2, 1, 3, 4)).reshape((1, B * H, T * W, C))
        tf.summary.image(name + '/grid', frames.astype(np.uint8), step)
